// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: players.sql

package db

import (
	"context"
	"time"
)

const getPlayerByNameTag = `-- name: GetPlayerByNameTag :one
SELECT puuid, name, tag, region, account_level, card, title, current_tier, current_tier_name, current_rr, is_partial_fetch, last_fetch_at, created_at, updated_at FROM players
WHERE name = ? AND tag = ?
LIMIT 1
`

type GetPlayerByNameTagParams struct {
	Name string `json:"name"`
	Tag  string `json:"tag"`
}

func (q *Queries) GetPlayerByNameTag(ctx context.Context, arg GetPlayerByNameTagParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, getPlayerByNameTag, arg.Name, arg.Tag)
	var i Player
	err := row.Scan(
		&i.Puuid,
		&i.Name,
		&i.Tag,
		&i.Region,
		&i.AccountLevel,
		&i.Card,
		&i.Title,
		&i.CurrentTier,
		&i.CurrentTierName,
		&i.CurrentRr,
		&i.IsPartialFetch,
		&i.LastFetchAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByPuuid = `-- name: GetPlayerByPuuid :one
SELECT puuid, name, tag, region, account_level, card, title, current_tier, current_tier_name, current_rr, is_partial_fetch, last_fetch_at, created_at, updated_at FROM players
WHERE puuid = ? LIMIT 1
`

func (q *Queries) GetPlayerByPuuid(ctx context.Context, puuid string) (Player, error) {
	row := q.db.QueryRowContext(ctx, getPlayerByPuuid, puuid)
	var i Player
	err := row.Scan(
		&i.Puuid,
		&i.Name,
		&i.Tag,
		&i.Region,
		&i.AccountLevel,
		&i.Card,
		&i.Title,
		&i.CurrentTier,
		&i.CurrentTierName,
		&i.CurrentRr,
		&i.IsPartialFetch,
		&i.LastFetchAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerLastFetchAt = `-- name: GetPlayerLastFetchAt :one
SELECT last_fetch_at, is_partial_fetch FROM players
WHERE puuid = ? LIMIT 1
`

type GetPlayerLastFetchAtRow struct {
	LastFetchAt    time.Time `json:"last_fetch_at"`
	IsPartialFetch bool      `json:"is_partial_fetch"`
}

func (q *Queries) GetPlayerLastFetchAt(ctx context.Context, puuid string) (GetPlayerLastFetchAtRow, error) {
	row := q.db.QueryRowContext(ctx, getPlayerLastFetchAt, puuid)
	var i GetPlayerLastFetchAtRow
	err := row.Scan(&i.LastFetchAt, &i.IsPartialFetch)
	return i, err
}

const searchPlayers = `-- name: SearchPlayers :many
SELECT puuid, name, tag, region, account_level, card, title, current_tier, current_tier_name, current_rr, is_partial_fetch, last_fetch_at, created_at, updated_at FROM players
WHERE name LIKE ? OR tag LIKE ?
ORDER BY account_level DESC
LIMIT ?
`

type SearchPlayersParams struct {
	Name  string `json:"name"`
	Tag   string `json:"tag"`
	Limit int64  `json:"limit"`
}

func (q *Queries) SearchPlayers(ctx context.Context, arg SearchPlayersParams) ([]Player, error) {
	rows, err := q.db.QueryContext(ctx, searchPlayers, arg.Name, arg.Tag, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.Puuid,
			&i.Name,
			&i.Tag,
			&i.Region,
			&i.AccountLevel,
			&i.Card,
			&i.Title,
			&i.CurrentTier,
			&i.CurrentTierName,
			&i.CurrentRr,
			&i.IsPartialFetch,
			&i.LastFetchAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayerLastFetchAt = `-- name: UpdatePlayerLastFetchAt :exec
UPDATE players
SET last_fetch_at = ?, updated_at = ?
WHERE puuid = ?
`

type UpdatePlayerLastFetchAtParams struct {
	LastFetchAt time.Time `json:"last_fetch_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Puuid       string    `json:"puuid"`
}

func (q *Queries) UpdatePlayerLastFetchAt(ctx context.Context, arg UpdatePlayerLastFetchAtParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayerLastFetchAt, arg.LastFetchAt, arg.UpdatedAt, arg.Puuid)
	return err
}

const updatePlayerPartialFetch = `-- name: UpdatePlayerPartialFetch :exec
UPDATE players
SET is_partial_fetch = ?, updated_at = ?
WHERE puuid = ?
`

type UpdatePlayerPartialFetchParams struct {
	IsPartialFetch bool      `json:"is_partial_fetch"`
	UpdatedAt      time.Time `json:"updated_at"`
	Puuid          string    `json:"puuid"`
}

func (q *Queries) UpdatePlayerPartialFetch(ctx context.Context, arg UpdatePlayerPartialFetchParams) error {
	_, err := q.db.ExecContext(ctx, updatePlayerPartialFetch, arg.IsPartialFetch, arg.UpdatedAt, arg.Puuid)
	return err
}

const upsertPlayer = `-- name: UpsertPlayer :exec
INSERT INTO players (
    puuid, name, tag, region, account_level, card, title,
    current_tier, current_tier_name, current_rr,
    is_partial_fetch, last_fetch_at, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(puuid) DO UPDATE SET
    name = excluded.name,
    tag = excluded.tag,
    region = excluded.region,
    account_level = excluded.account_level,
    card = excluded.card,
    title = excluded.title,
    current_tier = excluded.current_tier,
    current_tier_name = excluded.current_tier_name,
    current_rr = excluded.current_rr,
    is_partial_fetch = excluded.is_partial_fetch,
    last_fetch_at = excluded.last_fetch_at,
    updated_at = excluded.updated_at
`

type UpsertPlayerParams struct {
	Puuid           string    `json:"puuid"`
	Name            string    `json:"name"`
	Tag             string    `json:"tag"`
	Region          string    `json:"region"`
	AccountLevel    int64     `json:"account_level"`
	Card            string    `json:"card"`
	Title           string    `json:"title"`
	CurrentTier     int64     `json:"current_tier"`
	CurrentTierName string    `json:"current_tier_name"`
	CurrentRr       int64     `json:"current_rr"`
	IsPartialFetch  bool      `json:"is_partial_fetch"`
	LastFetchAt     time.Time `json:"last_fetch_at"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

func (q *Queries) UpsertPlayer(ctx context.Context, arg UpsertPlayerParams) error {
	_, err := q.db.ExecContext(ctx, upsertPlayer,
		arg.Puuid,
		arg.Name,
		arg.Tag,
		arg.Region,
		arg.AccountLevel,
		arg.Card,
		arg.Title,
		arg.CurrentTier,
		arg.CurrentTierName,
		arg.CurrentRr,
		arg.IsPartialFetch,
		arg.LastFetchAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
