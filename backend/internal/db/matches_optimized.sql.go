// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches_optimized.sql

package db

import (
	"context"
	"time"
)

const getMatchesWithPlayerDataByPuuid = `-- name: GetMatchesWithPlayerDataByPuuid :many
SELECT 
    m.match_id,
    m.map_name,
    m.map_id,
    m.mode,
    m.started_at,
    m.season_id,
    m.team_red_score,
    m.team_blue_score,
    m.region,
    m.cluster,
    m.version,
    m.source,
    m.created_at as match_created_at,
    m.updated_at as match_updated_at,
    mp.puuid,
    mp.name,
    mp.tag,
    mp.tier,
    mp.tier_name,
    mp.kills,
    mp.deaths,
    mp.assists,
    mp.score,
    mp.team,
    mp.has_won,
    mp.character_id,
    mp.damage_taken,
    mp.damage_dealt,
    mp.created_at as mp_created_at,
    mp.updated_at as mp_updated_at,
    mmr.id as mmr_id,
    mmr.tier as mmr_tier,
    mmr.tier_name as mmr_tier_name,
    mmr.ranking_in_tier,
    mmr.mmr_change,
    mmr.elo,
    mmr.date as mmr_date,
    mmr.source as mmr_source,
    mmr.created_at as mmr_created_at,
    mmr.updated_at as mmr_updated_at
FROM matches m
INNER JOIN match_players mp ON m.match_id = mp.match_id
LEFT JOIN mmr_histories mmr ON m.match_id = mmr.match_id AND mp.puuid = mmr.puuid
WHERE mp.puuid = ?
ORDER BY m.started_at DESC
`

type GetMatchesWithPlayerDataByPuuidRow struct {
	MatchID        string     `json:"match_id"`
	MapName        string     `json:"map_name"`
	MapID          string     `json:"map_id"`
	Mode           string     `json:"mode"`
	StartedAt      time.Time  `json:"started_at"`
	SeasonID       string     `json:"season_id"`
	TeamRedScore   int64      `json:"team_red_score"`
	TeamBlueScore  int64      `json:"team_blue_score"`
	Region         string     `json:"region"`
	Cluster        string     `json:"cluster"`
	Version        string     `json:"version"`
	Source         string     `json:"source"`
	MatchCreatedAt time.Time  `json:"match_created_at"`
	MatchUpdatedAt time.Time  `json:"match_updated_at"`
	Puuid          string     `json:"puuid"`
	Name           string     `json:"name"`
	Tag            string     `json:"tag"`
	Tier           int64      `json:"tier"`
	TierName       string     `json:"tier_name"`
	Kills          int64      `json:"kills"`
	Deaths         int64      `json:"deaths"`
	Assists        int64      `json:"assists"`
	Score          int64      `json:"score"`
	Team           string     `json:"team"`
	HasWon         bool       `json:"has_won"`
	CharacterID    string     `json:"character_id"`
	DamageTaken    int64      `json:"damage_taken"`
	DamageDealt    int64      `json:"damage_dealt"`
	MpCreatedAt    time.Time  `json:"mp_created_at"`
	MpUpdatedAt    time.Time  `json:"mp_updated_at"`
	MmrID          *string    `json:"mmr_id"`
	MmrTier        *int64     `json:"mmr_tier"`
	MmrTierName    *string    `json:"mmr_tier_name"`
	RankingInTier  *int64     `json:"ranking_in_tier"`
	MmrChange      *int64     `json:"mmr_change"`
	Elo            *int64     `json:"elo"`
	MmrDate        *time.Time `json:"mmr_date"`
	MmrSource      *string    `json:"mmr_source"`
	MmrCreatedAt   *time.Time `json:"mmr_created_at"`
	MmrUpdatedAt   *time.Time `json:"mmr_updated_at"`
}

func (q *Queries) GetMatchesWithPlayerDataByPuuid(ctx context.Context, puuid string) ([]GetMatchesWithPlayerDataByPuuidRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchesWithPlayerDataByPuuid, puuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMatchesWithPlayerDataByPuuidRow{}
	for rows.Next() {
		var i GetMatchesWithPlayerDataByPuuidRow
		if err := rows.Scan(
			&i.MatchID,
			&i.MapName,
			&i.MapID,
			&i.Mode,
			&i.StartedAt,
			&i.SeasonID,
			&i.TeamRedScore,
			&i.TeamBlueScore,
			&i.Region,
			&i.Cluster,
			&i.Version,
			&i.Source,
			&i.MatchCreatedAt,
			&i.MatchUpdatedAt,
			&i.Puuid,
			&i.Name,
			&i.Tag,
			&i.Tier,
			&i.TierName,
			&i.Kills,
			&i.Deaths,
			&i.Assists,
			&i.Score,
			&i.Team,
			&i.HasWon,
			&i.CharacterID,
			&i.DamageTaken,
			&i.DamageDealt,
			&i.MpCreatedAt,
			&i.MpUpdatedAt,
			&i.MmrID,
			&i.MmrTier,
			&i.MmrTierName,
			&i.RankingInTier,
			&i.MmrChange,
			&i.Elo,
			&i.MmrDate,
			&i.MmrSource,
			&i.MmrCreatedAt,
			&i.MmrUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
