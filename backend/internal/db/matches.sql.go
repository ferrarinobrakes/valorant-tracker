// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package db

import (
	"context"
	"strings"
	"time"
)

const countStoredGames = `-- name: CountStoredGames :one
SELECT COUNT(*) as count FROM matches m
INNER JOIN match_players mp ON m.match_id = mp.match_id
WHERE mp.puuid = ? AND m.source = 'stored'
`

func (q *Queries) CountStoredGames(ctx context.Context, puuid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStoredGames, puuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestMatchDate = `-- name: GetLatestMatchDate :one
SELECT m.started_at FROM matches m
INNER JOIN match_players mp ON m.match_id = mp.match_id
WHERE mp.puuid = ?
ORDER BY m.started_at DESC
LIMIT 1
`

func (q *Queries) GetLatestMatchDate(ctx context.Context, puuid string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getLatestMatchDate, puuid)
	var started_at time.Time
	err := row.Scan(&started_at)
	return started_at, err
}

const getMMRHistoryByMatchIDs = `-- name: GetMMRHistoryByMatchIDs :many
SELECT id, match_id, puuid, tier, tier_name, ranking_in_tier, mmr_change, elo, date, source, created_at, updated_at FROM mmr_histories
WHERE puuid = ? AND match_id IN (/*SLICE:match_ids*/?)
`

type GetMMRHistoryByMatchIDsParams struct {
	Puuid    string   `json:"puuid"`
	MatchIds []string `json:"match_ids"`
}

func (q *Queries) GetMMRHistoryByMatchIDs(ctx context.Context, arg GetMMRHistoryByMatchIDsParams) ([]MmrHistory, error) {
	query := getMMRHistoryByMatchIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Puuid)
	if len(arg.MatchIds) > 0 {
		for _, v := range arg.MatchIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:match_ids*/?", strings.Repeat(",?", len(arg.MatchIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:match_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MmrHistory{}
	for rows.Next() {
		var i MmrHistory
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.Puuid,
			&i.Tier,
			&i.TierName,
			&i.RankingInTier,
			&i.MmrChange,
			&i.Elo,
			&i.Date,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchMetadata = `-- name: GetMatchMetadata :one
SELECT match_id, map_name, map_id, mode, started_at, season_id, team_red_score, team_blue_score, region, cluster, version, source, created_at, updated_at FROM matches
WHERE match_id = ?
LIMIT 1
`

func (q *Queries) GetMatchMetadata(ctx context.Context, matchID string) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatchMetadata, matchID)
	var i Match
	err := row.Scan(
		&i.MatchID,
		&i.MapName,
		&i.MapID,
		&i.Mode,
		&i.StartedAt,
		&i.SeasonID,
		&i.TeamRedScore,
		&i.TeamBlueScore,
		&i.Region,
		&i.Cluster,
		&i.Version,
		&i.Source,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMatchPlayersByMatchID = `-- name: GetMatchPlayersByMatchID :many
SELECT match_id, puuid, name, tag, tier, tier_name, kills, deaths, assists, score, team, has_won, character_id, damage_taken, damage_dealt, created_at, updated_at FROM match_players
WHERE match_id = ?
`

func (q *Queries) GetMatchPlayersByMatchID(ctx context.Context, matchID string) ([]MatchPlayer, error) {
	rows, err := q.db.QueryContext(ctx, getMatchPlayersByMatchID, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchPlayer{}
	for rows.Next() {
		var i MatchPlayer
		if err := rows.Scan(
			&i.MatchID,
			&i.Puuid,
			&i.Name,
			&i.Tag,
			&i.Tier,
			&i.TierName,
			&i.Kills,
			&i.Deaths,
			&i.Assists,
			&i.Score,
			&i.Team,
			&i.HasWon,
			&i.CharacterID,
			&i.DamageTaken,
			&i.DamageDealt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchPlayersByMatchIDs = `-- name: GetMatchPlayersByMatchIDs :many
SELECT match_id, puuid, name, tag, tier, tier_name, kills, deaths, assists, score, team, has_won, character_id, damage_taken, damage_dealt, created_at, updated_at FROM match_players
WHERE puuid = ? AND match_id IN (/*SLICE:match_ids*/?)
`

type GetMatchPlayersByMatchIDsParams struct {
	Puuid    string   `json:"puuid"`
	MatchIds []string `json:"match_ids"`
}

func (q *Queries) GetMatchPlayersByMatchIDs(ctx context.Context, arg GetMatchPlayersByMatchIDsParams) ([]MatchPlayer, error) {
	query := getMatchPlayersByMatchIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Puuid)
	if len(arg.MatchIds) > 0 {
		for _, v := range arg.MatchIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:match_ids*/?", strings.Repeat(",?", len(arg.MatchIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:match_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MatchPlayer{}
	for rows.Next() {
		var i MatchPlayer
		if err := rows.Scan(
			&i.MatchID,
			&i.Puuid,
			&i.Name,
			&i.Tag,
			&i.Tier,
			&i.TierName,
			&i.Kills,
			&i.Deaths,
			&i.Assists,
			&i.Score,
			&i.Team,
			&i.HasWon,
			&i.CharacterID,
			&i.DamageTaken,
			&i.DamageDealt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByPuuid = `-- name: GetMatchesByPuuid :many
SELECT m.match_id, m.map_name, m.map_id, m.mode, m.started_at, m.season_id, m.team_red_score, m.team_blue_score, m.region, m.cluster, m.version, m.source, m.created_at, m.updated_at FROM matches m
INNER JOIN match_players mp ON m.match_id = mp.match_id
WHERE mp.puuid = ?
ORDER BY m.started_at DESC
`

func (q *Queries) GetMatchesByPuuid(ctx context.Context, puuid string) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, getMatchesByPuuid, puuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.MatchID,
			&i.MapName,
			&i.MapID,
			&i.Mode,
			&i.StartedAt,
			&i.SeasonID,
			&i.TeamRedScore,
			&i.TeamBlueScore,
			&i.Region,
			&i.Cluster,
			&i.Version,
			&i.Source,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMatch = `-- name: UpsertMatch :exec
INSERT INTO matches (
    match_id, map_name, map_id, mode, started_at, season_id,
    team_red_score, team_blue_score, region, cluster, version,
    source, created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(match_id) DO UPDATE SET
    map_name = excluded.map_name,
    map_id = excluded.map_id,
    mode = excluded.mode,
    started_at = excluded.started_at,
    season_id = excluded.season_id,
    team_red_score = excluded.team_red_score,
    team_blue_score = excluded.team_blue_score,
    region = excluded.region,
    cluster = excluded.cluster,
    version = excluded.version,
    source = excluded.source,
    updated_at = excluded.updated_at
`

type UpsertMatchParams struct {
	MatchID       string    `json:"match_id"`
	MapName       string    `json:"map_name"`
	MapID         string    `json:"map_id"`
	Mode          string    `json:"mode"`
	StartedAt     time.Time `json:"started_at"`
	SeasonID      string    `json:"season_id"`
	TeamRedScore  int64     `json:"team_red_score"`
	TeamBlueScore int64     `json:"team_blue_score"`
	Region        string    `json:"region"`
	Cluster       string    `json:"cluster"`
	Version       string    `json:"version"`
	Source        string    `json:"source"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

func (q *Queries) UpsertMatch(ctx context.Context, arg UpsertMatchParams) error {
	_, err := q.db.ExecContext(ctx, upsertMatch,
		arg.MatchID,
		arg.MapName,
		arg.MapID,
		arg.Mode,
		arg.StartedAt,
		arg.SeasonID,
		arg.TeamRedScore,
		arg.TeamBlueScore,
		arg.Region,
		arg.Cluster,
		arg.Version,
		arg.Source,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertMatchPlayer = `-- name: UpsertMatchPlayer :exec
INSERT INTO match_players (
    match_id, puuid, name, tag, tier, tier_name,
    kills, deaths, assists, score, team, has_won,
    character_id, damage_taken, damage_dealt,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(match_id, puuid) DO UPDATE SET
    name = excluded.name,
    tag = excluded.tag,
    tier = excluded.tier,
    tier_name = excluded.tier_name,
    kills = excluded.kills,
    deaths = excluded.deaths,
    assists = excluded.assists,
    score = excluded.score,
    team = excluded.team,
    has_won = excluded.has_won,
    character_id = excluded.character_id,
    damage_taken = excluded.damage_taken,
    damage_dealt = excluded.damage_dealt,
    updated_at = excluded.updated_at
`

type UpsertMatchPlayerParams struct {
	MatchID     string    `json:"match_id"`
	Puuid       string    `json:"puuid"`
	Name        string    `json:"name"`
	Tag         string    `json:"tag"`
	Tier        int64     `json:"tier"`
	TierName    string    `json:"tier_name"`
	Kills       int64     `json:"kills"`
	Deaths      int64     `json:"deaths"`
	Assists     int64     `json:"assists"`
	Score       int64     `json:"score"`
	Team        string    `json:"team"`
	HasWon      bool      `json:"has_won"`
	CharacterID string    `json:"character_id"`
	DamageTaken int64     `json:"damage_taken"`
	DamageDealt int64     `json:"damage_dealt"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) UpsertMatchPlayer(ctx context.Context, arg UpsertMatchPlayerParams) error {
	_, err := q.db.ExecContext(ctx, upsertMatchPlayer,
		arg.MatchID,
		arg.Puuid,
		arg.Name,
		arg.Tag,
		arg.Tier,
		arg.TierName,
		arg.Kills,
		arg.Deaths,
		arg.Assists,
		arg.Score,
		arg.Team,
		arg.HasWon,
		arg.CharacterID,
		arg.DamageTaken,
		arg.DamageDealt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
